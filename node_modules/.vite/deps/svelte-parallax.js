import "./chunk-MXOI6PWM.js";
import {
  spring
} from "./chunk-TTZK7HVE.js";
import "./chunk-DKNDEOWF.js";
import {
  derived,
  writable
} from "./chunk-JQBJKKUJ.js";
import {
  cubicInOut,
  quadInOut
} from "./chunk-VFRMSNTO.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  add_location,
  add_render_callback,
  append_styles,
  assign,
  binding_callbacks,
  children,
  claim_element,
  component_subscribe,
  compute_rest_props,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_update,
  globals,
  init,
  insert_hydration_dev,
  listen_dev,
  loop,
  noop,
  now,
  onMount,
  run_all,
  safe_not_equal,
  setContext,
  set_attributes,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-YHIUKQUI.js";
import "./chunk-5UFCALFR.js";
import "./chunk-2B2CG5KL.js";

// node_modules/svelte-parallax/src/utils/writableSet.js
function writableSet(value = /* @__PURE__ */ new Set()) {
  const store = writable(value);
  const wrap = (method) => {
    return (...args) => {
      let output;
      store.update((value2) => {
        output = value2[method](...args);
        return value2;
      });
      return output;
    };
  };
  return {
    ...store,
    add: wrap("add"),
    delete: wrap("delete")
  };
}

// node_modules/svelte-parallax/src/utils/contextKey.js
var contextKey = {};

// node_modules/svelte-parallax/src/utils/clamp.js
var clamp = (val, min, max) => {
  return val < min ? min : val > max ? max : val;
};

// node_modules/svelte-parallax/src/scroll-fork/helper.js
var supportsPassive = false;
try {
  let opts = Object.defineProperty({}, "passive", {
    get: function() {
      supportsPassive = true;
    }
  });
  window.addEventListener("test", null, opts);
} catch (e) {
}
var helper_default = {
  $(selector) {
    if (typeof selector === "string") {
      return document.querySelector(selector);
    }
    return selector;
  },
  extend(...args) {
    return Object.assign(...args);
  },
  addListeners(element2, events, handler, opts = { passive: false }) {
    if (!(events instanceof Array)) {
      events = [events];
    }
    for (let i = 0; i < events.length; i++) {
      element2.addEventListener(
        events[i],
        handler,
        supportsPassive ? opts : false
      );
    }
  },
  removeListeners(element2, events, handler) {
    if (!(events instanceof Array)) {
      events = [events];
    }
    for (let i = 0; i < events.length; i++) {
      element2.removeEventListener(events[i], handler);
    }
  },
  cumulativeOffset(element2) {
    let top = 0;
    let left = 0;
    do {
      top += element2.offsetTop || 0;
      left += element2.offsetLeft || 0;
      element2 = element2.offsetParent;
    } while (element2);
    return {
      top,
      left
    };
  },
  directScroll(element2) {
    return element2 && element2 !== document && element2 !== document.body;
  },
  scrollTop(element2, value) {
    let inSetter = value !== void 0;
    if (this.directScroll(element2)) {
      return inSetter ? element2.scrollTop = value : element2.scrollTop;
    } else {
      return inSetter ? document.documentElement.scrollTop = document.body.scrollTop = value : window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
    }
  },
  scrollLeft(element2, value) {
    let inSetter = value !== void 0;
    if (this.directScroll(element2)) {
      return inSetter ? element2.scrollLeft = value : element2.scrollLeft;
    } else {
      return inSetter ? document.documentElement.scrollLeft = document.body.scrollLeft = value : window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
    }
  }
};

// node_modules/svelte-parallax/src/scroll-fork/svelteScrollTo.js
var defaultOptions = {
  container: "body",
  duration: 500,
  delay: 0,
  offset: 0,
  easing: cubicInOut,
  onStart: noop,
  onDone: noop,
  onAborting: noop,
  scrollX: false,
  scrollY: true
};
var abortEvents = [
  "mousedown",
  "wheel",
  "DOMMouseScroll",
  "mousewheel",
  "keydown",
  "touchmove"
];
var _scrollTo = (options) => {
  let {
    offset,
    duration,
    delay,
    easing,
    x = 0,
    y = 0,
    scrollX,
    scrollY,
    onStart,
    onDone,
    container,
    onAborting,
    element: element2
  } = options;
  if (typeof offset === "function") {
    offset = offset();
  }
  const cumulativeOffsetContainer = helper_default.cumulativeOffset(container);
  const cumulativeOffsetTarget = element2 ? helper_default.cumulativeOffset(element2) : { top: y, left: x };
  const initialX = helper_default.scrollLeft(container);
  const initialY = helper_default.scrollTop(container);
  const targetX = cumulativeOffsetTarget.left - cumulativeOffsetContainer.left + offset;
  const targetY = cumulativeOffsetTarget.top - cumulativeOffsetContainer.top + offset;
  const diffX = targetX - initialX;
  const diffY = targetY - initialY;
  let scrolling = true;
  let started = false;
  let start_time = now() + delay;
  let end_time = start_time + duration;
  function scrollToTopLeft(element3, top, left) {
    if (scrollX)
      helper_default.scrollLeft(element3, left);
    if (scrollY)
      helper_default.scrollTop(element3, top);
  }
  function start(delayStart) {
    if (!delayStart) {
      started = true;
      onStart(element2, { x, y });
    }
    helper_default.addListeners(container, abortEvents, stop, { passive: true });
  }
  function tick(progress) {
    scrollToTopLeft(
      container,
      initialY + diffY * progress,
      initialX + diffX * progress
    );
  }
  function stop() {
    scrolling = false;
    helper_default.removeListeners(container, abortEvents, stop);
  }
  loop((now2) => {
    if (!started && now2 >= start_time) {
      start(false);
    }
    if (started && now2 >= end_time) {
      tick(1);
      stop();
      onDone(element2, { x, y });
      return false;
    }
    if (!scrolling) {
      onAborting(element2, { x, y });
      return false;
    }
    if (started) {
      const p = now2 - start_time;
      const t = 0 + 1 * easing(p / duration);
      tick(t);
    }
    return true;
  });
  start(delay);
  tick(0);
  return stop;
};
var proceedOptions = (options) => {
  let opts = helper_default.extend({}, defaultOptions, options);
  opts.container = helper_default.$(opts.container);
  opts.element = helper_default.$(opts.element);
  return opts;
};
var scrollContainerHeight = (containerElement) => {
  if (containerElement && containerElement !== document && containerElement !== document.body) {
    return containerElement.scrollHeight - containerElement.offsetHeight;
  } else {
    let body = document.body;
    let html = document.documentElement;
    return Math.max(
      body.scrollHeight,
      body.offsetHeight,
      html.clientHeight,
      html.scrollHeight,
      html.offsetHeight
    );
  }
};
var scrollTo = (options) => {
  return _scrollTo(proceedOptions(options));
};
var scrollToBottom = (options) => {
  options = proceedOptions(options);
  return _scrollTo(
    helper_default.extend(options, {
      element: null,
      y: scrollContainerHeight(options.container)
    })
  );
};
var scrollToTop = (options) => {
  options = proceedOptions(options);
  return _scrollTo(
    helper_default.extend(options, {
      element: null,
      y: 0
    })
  );
};
var makeScrollToAction = (scrollToFunc) => {
  return (node, options) => {
    let current = options;
    const handle = (e) => {
      e.preventDefault();
      scrollToFunc(
        typeof current === "string" ? { element: current } : current
      );
    };
    helper_default.addListeners(node, ["click", "touchstart"], handle);
    return {
      update(options2) {
        current = options2;
      },
      destroy() {
        helper_default.removeListeners(node, ["click", "touchstart"], handle);
      }
    };
  };
};
var scrollto = makeScrollToAction(scrollTo);
var scrolltotop = makeScrollToAction(scrollToTop);
var scrolltobottom = makeScrollToAction(scrollToBottom);

// node_modules/svelte-parallax/src/Parallax.svelte
var { scrollTo: scrollTo_1, setTimeout: setTimeout_1, window: window_1 } = globals;
var file = "node_modules/svelte-parallax/src/Parallax.svelte";
function add_css(target) {
  append_styles(target, "svelte-15ph2c6", ".parallax-container.svelte-15ph2c6{position:relative;overflow:hidden;box-sizing:border-box}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGFyYWxsYXguc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL2FtZ2xhc3MxMi9Eb2N1bWVudHMvR2l0SHViL2FsbGVuL25vZGVfbW9kdWxlcy9zdmVsdGUtcGFyYWxsYXgvc3JjL1BhcmFsbGF4LnN2ZWx0ZSJdfQ== */");
}
function create_fragment(ctx) {
  let scrolling = false;
  let clear_scrolling = () => {
    scrolling = false;
  };
  let scrolling_timeout;
  let div;
  let div_class_value;
  let div_style_value;
  let current;
  let mounted;
  let dispose;
  add_render_callback(
    /*onwindowscroll*/
    ctx[26]
  );
  add_render_callback(
    /*onwindowresize*/
    ctx[27]
  );
  const default_slot_template = (
    /*#slots*/
    ctx[24].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[12],
    {
      class: div_class_value = "parallax-container " + /*$$restProps*/
      (ctx[12].class ? (
        /*$$restProps*/
        ctx[12].class
      ) : "")
    },
    {
      style: div_style_value = "height: " + /*$height*/
      ctx[1] * /*sections*/
      ctx[0] + "px; " + /*$$restProps*/
      (ctx[12].style ? (
        /*$$restProps*/
        ctx[12].style
      ) : "") + ";"
    }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "svelte-15ph2c6", true);
      add_location(div, file, -1, 3603);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[28](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window_1,
            "resize",
            /*resize_handler*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(window_1, "scroll", () => {
            scrolling = true;
            clearTimeout(scrolling_timeout);
            scrolling_timeout = setTimeout_1(clear_scrolling, 100);
            ctx[26]();
          }),
          listen_dev(
            window_1,
            "resize",
            /*onwindowresize*/
            ctx[27]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$y*/
      16 && !scrolling) {
        scrolling = true;
        clearTimeout(scrolling_timeout);
        scrollTo_1(
          window_1.pageXOffset,
          /*$y*/
          ctx2[4]
        );
        scrolling_timeout = setTimeout_1(clear_scrolling, 100);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8388608)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx2[12],
        (!current || dirty & /*$$restProps*/
        4096 && div_class_value !== (div_class_value = "parallax-container " + /*$$restProps*/
        (ctx2[12].class ? (
          /*$$restProps*/
          ctx2[12].class
        ) : ""))) && { class: div_class_value },
        (!current || dirty & /*$height, sections, $$restProps*/
        4099 && div_style_value !== (div_style_value = "height: " + /*$height*/
        ctx2[1] * /*sections*/
        ctx2[0] + "px; " + /*$$restProps*/
        (ctx2[12].style ? (
          /*$$restProps*/
          ctx2[12].style
        ) : "") + ";")) && { style: div_style_value }
      ]));
      toggle_class(div, "svelte-15ph2c6", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[28](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "sections",
    "sectionHeight",
    "config",
    "threshold",
    "onProgress",
    "onScroll",
    "disabled",
    "scrollTo"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $height;
  let $top;
  let $scrollTop;
  let $layers;
  let $progress;
  let $y;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Parallax", slots, ["default"]);
  let container;
  let innerHeight;
  let { sections = 1 } = $$props;
  let { sectionHeight = void 0 } = $$props;
  let { config = { stiffness: 0.017, damping: 0.26 } } = $$props;
  let { threshold = { top: 1, bottom: 1 } } = $$props;
  let { onProgress = void 0 } = $$props;
  let { onScroll = void 0 } = $$props;
  let { disabled = false } = $$props;
  const y = writable(0);
  validate_store(y, "y");
  component_subscribe($$self, y, (value) => $$invalidate(4, $y = value));
  const top = writable(0);
  validate_store(top, "top");
  component_subscribe($$self, top, (value) => $$invalidate(29, $top = value));
  const height = writable(0);
  validate_store(height, "height");
  component_subscribe($$self, height, (value) => $$invalidate(1, $height = value));
  const progress = spring(void 0, { ...config, precision: 1e-3 });
  validate_store(progress, "progress");
  component_subscribe($$self, progress, (value) => $$invalidate(22, $progress = value));
  const scrollTop = derived([y, top, height], ([$y2, $top2, $height2], set) => {
    const dy = $y2 - $top2;
    const min = 0 - $height2 + $height2 * threshold.top;
    const max = $height2 * sections - $height2 * threshold.bottom;
    const step = clamp(dy, min, max);
    set(step);
  });
  validate_store(scrollTop, "scrollTop");
  component_subscribe($$self, scrollTop, (value) => $$invalidate(20, $scrollTop = value));
  const setProgress = (scrollTop2, height2) => {
    if (height2 === 0) {
      progress.set(0);
      return;
    }
    const scrollHeight = height2 * sections - height2;
    progress.set(clamp(scrollTop2 / scrollHeight, 0, 1));
  };
  const layers = writableSet(/* @__PURE__ */ new Set());
  validate_store(layers, "layers");
  component_subscribe($$self, layers, (value) => $$invalidate(21, $layers = value));
  setContext(contextKey, {
    config,
    addLayer: (layer) => {
      layers.add(layer);
    },
    removeLayer: (layer) => {
      layers.delete(layer);
    }
  });
  onMount(() => {
    setDimensions();
  });
  const setDimensions = () => {
    height.set(sectionHeight ? sectionHeight : innerHeight);
    top.set(container.getBoundingClientRect().top + window.pageYOffset);
  };
  function scrollTo2(section, { selector = "", duration = 500, easing = quadInOut } = {}) {
    const scrollTarget = $top + $height * (section - 1);
    const focusTarget = () => {
      document.querySelector(selector).focus({ preventScroll: true });
    };
    if (disabled) {
      window.scrollTo({ top: scrollTarget });
      selector && focusTarget();
      return;
    }
    scrollTo({
      y: scrollTarget,
      duration,
      easing,
      onDone: selector ? focusTarget : () => {
      }
    });
  }
  const resize_handler = () => setTimeout(setDimensions, 0);
  function onwindowscroll() {
    y.set($y = window_1.pageYOffset);
  }
  function onwindowresize() {
    $$invalidate(3, innerHeight = window_1.innerHeight);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(2, container);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("sections" in $$new_props)
      $$invalidate(0, sections = $$new_props.sections);
    if ("sectionHeight" in $$new_props)
      $$invalidate(13, sectionHeight = $$new_props.sectionHeight);
    if ("config" in $$new_props)
      $$invalidate(14, config = $$new_props.config);
    if ("threshold" in $$new_props)
      $$invalidate(15, threshold = $$new_props.threshold);
    if ("onProgress" in $$new_props)
      $$invalidate(16, onProgress = $$new_props.onProgress);
    if ("onScroll" in $$new_props)
      $$invalidate(17, onScroll = $$new_props.onScroll);
    if ("disabled" in $$new_props)
      $$invalidate(18, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props)
      $$invalidate(23, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    onMount,
    spring,
    writable,
    derived,
    quadInOut,
    writableSet,
    contextKey,
    clamp,
    svelteScrollTo: scrollTo,
    container,
    innerHeight,
    sections,
    sectionHeight,
    config,
    threshold,
    onProgress,
    onScroll,
    disabled,
    y,
    top,
    height,
    progress,
    scrollTop,
    setProgress,
    layers,
    setDimensions,
    scrollTo: scrollTo2,
    $height,
    $top,
    $scrollTop,
    $layers,
    $progress,
    $y
  });
  $$self.$inject_state = ($$new_props) => {
    if ("container" in $$props)
      $$invalidate(2, container = $$new_props.container);
    if ("innerHeight" in $$props)
      $$invalidate(3, innerHeight = $$new_props.innerHeight);
    if ("sections" in $$props)
      $$invalidate(0, sections = $$new_props.sections);
    if ("sectionHeight" in $$props)
      $$invalidate(13, sectionHeight = $$new_props.sectionHeight);
    if ("config" in $$props)
      $$invalidate(14, config = $$new_props.config);
    if ("threshold" in $$props)
      $$invalidate(15, threshold = $$new_props.threshold);
    if ("onProgress" in $$props)
      $$invalidate(16, onProgress = $$new_props.onProgress);
    if ("onScroll" in $$props)
      $$invalidate(17, onScroll = $$new_props.onScroll);
    if ("disabled" in $$props)
      $$invalidate(18, disabled = $$new_props.disabled);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*onScroll, $scrollTop*/
    1179648) {
      $:
        if (onScroll)
          onScroll($scrollTop);
    }
    if ($$self.$$.dirty & /*onProgress, $scrollTop, $height*/
    1114114) {
      $:
        if (onProgress)
          setProgress($scrollTop, $height);
    }
    if ($$self.$$.dirty & /*onProgress, $progress*/
    4259840) {
      $:
        if (onProgress)
          onProgress($progress ?? 0);
    }
    if ($$self.$$.dirty & /*$layers, $height*/
    2097154) {
      $:
        $layers.forEach((layer) => {
          layer.setHeight($height);
        });
    }
    if ($$self.$$.dirty & /*$layers, $scrollTop, $height, disabled*/
    3407874) {
      $:
        $layers.forEach((layer) => {
          layer.setPosition($scrollTop, $height, disabled);
        });
    }
    if ($$self.$$.dirty & /*$height, sectionHeight*/
    8194) {
      $:
        if ($height !== 0)
          sectionHeight, setDimensions();
    }
  };
  return [
    sections,
    $height,
    container,
    innerHeight,
    $y,
    y,
    top,
    height,
    progress,
    scrollTop,
    layers,
    setDimensions,
    $$restProps,
    sectionHeight,
    config,
    threshold,
    onProgress,
    onScroll,
    disabled,
    scrollTo2,
    $scrollTop,
    $layers,
    $progress,
    $$scope,
    slots,
    resize_handler,
    onwindowscroll,
    onwindowresize,
    div_binding
  ];
}
var Parallax = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        sections: 0,
        sectionHeight: 13,
        config: 14,
        threshold: 15,
        onProgress: 16,
        onScroll: 17,
        disabled: 18,
        scrollTo: 19
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Parallax",
      options,
      id: create_fragment.name
    });
  }
  get sections() {
    throw new Error("<Parallax>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sections(value) {
    throw new Error("<Parallax>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sectionHeight() {
    throw new Error("<Parallax>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sectionHeight(value) {
    throw new Error("<Parallax>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get config() {
    throw new Error("<Parallax>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<Parallax>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get threshold() {
    throw new Error("<Parallax>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set threshold(value) {
    throw new Error("<Parallax>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onProgress() {
    throw new Error("<Parallax>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onProgress(value) {
    throw new Error("<Parallax>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onScroll() {
    throw new Error("<Parallax>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onScroll(value) {
    throw new Error("<Parallax>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Parallax>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Parallax>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollTo() {
    return this.$$.ctx[19];
  }
  set scrollTo(value) {
    throw new Error("<Parallax>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Parallax_default = Parallax;

// node_modules/svelte-parallax/src/ParallaxLayer.svelte
var file2 = "node_modules/svelte-parallax/src/ParallaxLayer.svelte";
function add_css2(target) {
  append_styles(target, "svelte-qcp0z5", ".parallax-layer.svelte-qcp0z5{width:100%;position:absolute;box-sizing:border-box}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGFyYWxsYXhMYXllci5zdmVsdGUiLCJtYXBwaW5ncyI6IiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvYW1nbGFzczEyL0RvY3VtZW50cy9HaXRIdWIvYWxsZW4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1wYXJhbGxheC9zcmMvUGFyYWxsYXhMYXllci5zdmVsdGUiXX0= */");
}
var get_default_slot_changes = (dirty) => ({ progress: dirty & /*$progress*/
1 });
var get_default_slot_context = (ctx) => ({ progress: (
  /*$progress*/
  ctx[0]
) });
function create_fragment2(ctx) {
  let div;
  let div_class_value;
  let div_style_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_default_slot_context
  );
  let div_levels = [
    /*$$restProps*/
    ctx[5],
    {
      class: div_class_value = "parallax-layer " + /*$$restProps*/
      (ctx[5].class ? (
        /*$$restProps*/
        ctx[5].class
      ) : "")
    },
    {
      style: div_style_value = "" + /*$$restProps*/
      (ctx[5].style ? (
        /*$$restProps*/
        ctx[5].style
      ) : "") + "; height: " + /*height*/
      ctx[1] + "px; -ms-transform: " + /*translate*/
      ctx[2] + "; -webkit-transform: " + /*translate*/
      ctx[2] + "; transform: " + /*translate*/
      ctx[2] + ";"
    }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "svelte-qcp0z5", true);
      add_location(div, file2, -1, 2261);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $progress*/
        2049)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        (!current || dirty & /*$$restProps*/
        32 && div_class_value !== (div_class_value = "parallax-layer " + /*$$restProps*/
        (ctx2[5].class ? (
          /*$$restProps*/
          ctx2[5].class
        ) : ""))) && { class: div_class_value },
        (!current || dirty & /*$$restProps, height, translate*/
        38 && div_style_value !== (div_style_value = "" + /*$$restProps*/
        (ctx2[5].style ? (
          /*$$restProps*/
          ctx2[5].style
        ) : "") + "; height: " + /*height*/
        ctx2[1] + "px; -ms-transform: " + /*translate*/
        ctx2[2] + "; -webkit-transform: " + /*translate*/
        ctx2[2] + "; transform: " + /*translate*/
        ctx2[2] + ";")) && { style: div_style_value }
      ]));
      toggle_class(div, "svelte-qcp0z5", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let translate;
  const omit_props_names = ["rate", "offset", "span", "onProgress"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $progress;
  let $coord;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ParallaxLayer", slots, ["default"]);
  let { rate = 0.5 } = $$props;
  let { offset = 0 } = $$props;
  let { span = 1 } = $$props;
  let { onProgress = void 0 } = $$props;
  const { config, addLayer, removeLayer } = getContext(contextKey);
  const coord = spring(void 0, config);
  validate_store(coord, "coord");
  component_subscribe($$self, coord, (value) => $$invalidate(10, $coord = value));
  const progress = spring(void 0, { ...config, precision: 1e-3 });
  validate_store(progress, "progress");
  component_subscribe($$self, progress, (value) => $$invalidate(0, $progress = value));
  let height;
  const layer = {
    setPosition: (scrollTop, sectionHeight, disabled) => {
      if (disabled) {
        coord.set(offset * sectionHeight, { hard: true });
        return;
      }
      const targetScroll = Math.floor(offset) * sectionHeight;
      const distance = offset * sectionHeight + targetScroll * rate;
      coord.set(-(scrollTop * rate) + distance);
      progress.set(getProgress(scrollTop, rate, distance, sectionHeight));
    },
    setHeight: (sectionHeight) => {
      $$invalidate(1, height = span * sectionHeight);
    }
  };
  const getProgress = (scrollTop, rate2, distance, sectionHeight) => {
    const apparentRate = rate2 + 1;
    const halfWay = distance / apparentRate;
    const direction = rate2 >= 0 ? 1 : -1;
    const scrollDistance = sectionHeight / apparentRate * direction;
    const start = halfWay - scrollDistance;
    const end = halfWay + scrollDistance * span;
    const progress2 = (scrollTop - start) / (end - start);
    return clamp(progress2, 0, 1);
  };
  onMount(() => {
    addLayer(layer);
    return () => {
      removeLayer(layer);
    };
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("rate" in $$new_props)
      $$invalidate(6, rate = $$new_props.rate);
    if ("offset" in $$new_props)
      $$invalidate(7, offset = $$new_props.offset);
    if ("span" in $$new_props)
      $$invalidate(8, span = $$new_props.span);
    if ("onProgress" in $$new_props)
      $$invalidate(9, onProgress = $$new_props.onProgress);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    onMount,
    spring,
    contextKey,
    clamp,
    rate,
    offset,
    span,
    onProgress,
    config,
    addLayer,
    removeLayer,
    coord,
    progress,
    height,
    layer,
    getProgress,
    translate,
    $progress,
    $coord
  });
  $$self.$inject_state = ($$new_props) => {
    if ("rate" in $$props)
      $$invalidate(6, rate = $$new_props.rate);
    if ("offset" in $$props)
      $$invalidate(7, offset = $$new_props.offset);
    if ("span" in $$props)
      $$invalidate(8, span = $$new_props.span);
    if ("onProgress" in $$props)
      $$invalidate(9, onProgress = $$new_props.onProgress);
    if ("height" in $$props)
      $$invalidate(1, height = $$new_props.height);
    if ("translate" in $$props)
      $$invalidate(2, translate = $$new_props.translate);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$coord*/
    1024) {
      $:
        $$invalidate(2, translate = `translate3d(0px, ${$coord}px, 0px);`);
    }
    if ($$self.$$.dirty & /*onProgress, $progress*/
    513) {
      $:
        if (onProgress)
          onProgress($progress ?? 0);
    }
  };
  return [
    $progress,
    height,
    translate,
    coord,
    progress,
    $$restProps,
    rate,
    offset,
    span,
    onProgress,
    $coord,
    $$scope,
    slots
  ];
}
var ParallaxLayer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        rate: 6,
        offset: 7,
        span: 8,
        onProgress: 9
      },
      add_css2
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ParallaxLayer",
      options,
      id: create_fragment2.name
    });
  }
  get rate() {
    throw new Error("<ParallaxLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rate(value) {
    throw new Error("<ParallaxLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get offset() {
    throw new Error("<ParallaxLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set offset(value) {
    throw new Error("<ParallaxLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get span() {
    throw new Error("<ParallaxLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set span(value) {
    throw new Error("<ParallaxLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onProgress() {
    throw new Error("<ParallaxLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onProgress(value) {
    throw new Error("<ParallaxLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ParallaxLayer_default = ParallaxLayer;

// node_modules/svelte-parallax/src/StickyLayer.svelte
var file3 = "node_modules/svelte-parallax/src/StickyLayer.svelte";
function add_css3(target) {
  append_styles(target, "svelte-1t1wv58", ".sticky-layer.svelte-1t1wv58{width:100%;top:0;left:0;box-sizing:border-box}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3RpY2t5TGF5ZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL2FtZ2xhc3MxMi9Eb2N1bWVudHMvR2l0SHViL2FsbGVuL25vZGVfbW9kdWxlcy9zdmVsdGUtcGFyYWxsYXgvc3JjL1N0aWNreUxheWVyLnN2ZWx0ZSJdfQ== */");
}
var get_default_slot_changes2 = (dirty) => ({ progress: dirty & /*$progress*/
1 });
var get_default_slot_context2 = (ctx) => ({ progress: (
  /*$progress*/
  ctx[0]
) });
function create_fragment3(ctx) {
  let div;
  let div_class_value;
  let div_style_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context2
  );
  let div_levels = [
    /*$$restProps*/
    ctx[5],
    {
      class: div_class_value = "sticky-layer " + /*$$restProps*/
      (ctx[5].class ? (
        /*$$restProps*/
        ctx[5].class
      ) : "")
    },
    {
      style: div_style_value = "" + /*$$restProps*/
      (ctx[5].style ? (
        /*$$restProps*/
        ctx[5].style
      ) : "") + "; position: " + /*position*/
      ctx[3] + "; height: " + /*height*/
      ctx[1] + "px; -ms-transform: " + /*translate*/
      ctx[2] + " -webkit-transform: " + /*translate*/
      ctx[2] + " transform: " + /*translate*/
      ctx[2]
    }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "svelte-1t1wv58", true);
      add_location(div, file3, -1, 1975);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $progress*/
        1025)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes2
            ),
            get_default_slot_context2
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        (!current || dirty & /*$$restProps*/
        32 && div_class_value !== (div_class_value = "sticky-layer " + /*$$restProps*/
        (ctx2[5].class ? (
          /*$$restProps*/
          ctx2[5].class
        ) : ""))) && { class: div_class_value },
        (!current || dirty & /*$$restProps, position, height, translate*/
        46 && div_style_value !== (div_style_value = "" + /*$$restProps*/
        (ctx2[5].style ? (
          /*$$restProps*/
          ctx2[5].style
        ) : "") + "; position: " + /*position*/
        ctx2[3] + "; height: " + /*height*/
        ctx2[1] + "px; -ms-transform: " + /*translate*/
        ctx2[2] + " -webkit-transform: " + /*translate*/
        ctx2[2] + " transform: " + /*translate*/
        ctx2[2])) && { style: div_style_value }
      ]));
      toggle_class(div, "svelte-1t1wv58", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let position;
  let translate;
  const omit_props_names = ["offset", "onProgress"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $progress;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StickyLayer", slots, ["default"]);
  let { offset = { top: 0, bottom: 0 } } = $$props;
  let { onProgress = void 0 } = $$props;
  const { config, addLayer, removeLayer } = getContext(contextKey);
  let isSticky = false;
  let coord = 0;
  let height;
  const progress = spring(0, { ...config, precision: 1e-3 });
  validate_store(progress, "progress");
  component_subscribe($$self, progress, (value) => $$invalidate(0, $progress = value));
  const layer = {
    setPosition: (scrollTop, sectionHeight, disabled) => {
      if (disabled) {
        $$invalidate(8, isSticky = false);
        $$invalidate(9, coord = sectionHeight * offset.top);
        return;
      }
      const start = sectionHeight * offset.top;
      const end = sectionHeight * (offset.bottom || offset.top + 1);
      $$invalidate(8, isSticky = getSticky(scrollTop, start, end));
      $$invalidate(9, coord = getCoord(scrollTop, start, end, isSticky));
      progress.set(clamp((scrollTop - start) / (end - start), 0, 1));
    },
    setHeight: (sectionHeight) => {
      $$invalidate(1, height = sectionHeight);
    }
  };
  const getSticky = (scrollTop, start, end) => {
    const startCondition = start === 0 ? scrollTop > start : scrollTop >= start;
    return startCondition && scrollTop <= end;
  };
  const getCoord = (scrollTop, start, end, isSticky2) => {
    if (isSticky2)
      return 0;
    return scrollTop <= start ? start : end;
  };
  onMount(() => {
    addLayer(layer);
    return () => {
      removeLayer(layer);
    };
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("offset" in $$new_props)
      $$invalidate(6, offset = $$new_props.offset);
    if ("onProgress" in $$new_props)
      $$invalidate(7, onProgress = $$new_props.onProgress);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    onMount,
    spring,
    contextKey,
    clamp,
    offset,
    onProgress,
    config,
    addLayer,
    removeLayer,
    isSticky,
    coord,
    height,
    progress,
    layer,
    getSticky,
    getCoord,
    translate,
    position,
    $progress
  });
  $$self.$inject_state = ($$new_props) => {
    if ("offset" in $$props)
      $$invalidate(6, offset = $$new_props.offset);
    if ("onProgress" in $$props)
      $$invalidate(7, onProgress = $$new_props.onProgress);
    if ("isSticky" in $$props)
      $$invalidate(8, isSticky = $$new_props.isSticky);
    if ("coord" in $$props)
      $$invalidate(9, coord = $$new_props.coord);
    if ("height" in $$props)
      $$invalidate(1, height = $$new_props.height);
    if ("translate" in $$props)
      $$invalidate(2, translate = $$new_props.translate);
    if ("position" in $$props)
      $$invalidate(3, position = $$new_props.position);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*isSticky*/
    256) {
      $:
        $$invalidate(3, position = isSticky ? "fixed" : "absolute");
    }
    if ($$self.$$.dirty & /*coord*/
    512) {
      $:
        $$invalidate(2, translate = `translate3d(0px, ${coord}px, 0px);`);
    }
    if ($$self.$$.dirty & /*onProgress, $progress*/
    129) {
      $:
        if (onProgress)
          onProgress($progress ?? 0);
    }
  };
  return [
    $progress,
    height,
    translate,
    position,
    progress,
    $$restProps,
    offset,
    onProgress,
    isSticky,
    coord,
    $$scope,
    slots
  ];
}
var StickyLayer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { offset: 6, onProgress: 7 }, add_css3);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StickyLayer",
      options,
      id: create_fragment3.name
    });
  }
  get offset() {
    throw new Error("<StickyLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set offset(value) {
    throw new Error("<StickyLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onProgress() {
    throw new Error("<StickyLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onProgress(value) {
    throw new Error("<StickyLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StickyLayer_default = StickyLayer;
export {
  Parallax_default as Parallax,
  ParallaxLayer_default as ParallaxLayer,
  StickyLayer_default as StickyLayer
};
//# sourceMappingURL=svelte-parallax.js.map
